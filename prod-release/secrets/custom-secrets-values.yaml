global:
  control_api_tls: true

dockerCredentials:
  registry: docker.production.deciphernow.com
  email:
  username:
  password:

data:
  name: data
  deploy:
    standalone: false
  aws:
    access_key: ""
    secret_key: ""
    region: us-east-1
    bucket: decipher-quickstart-helm
  master_key: ""
mongo:
  credentials:
    secret_name: mongo-password
    # The credentials to be used to communicate with Mongo and the database to be created
    root_username: ""
    root_password: ""
    database: ""
    admin_password: ""
    gmdata_username: ""
    gmdata_password: ""
  secret:
    secret_name: "mongo-certs"
      # If from_file is true then you need to place cert files into the direcroty specified in path
      # Looking for ca.crt, server.cert, and server.key
    certificates:
      from_file:
        enabled: false
        path: files/certs/mongo
      ca: ""
      cert: ""
      key: ""

internaldata:
  name: internal-data
  deploy: 
    standalone: false
  aws:
    access_key: ""
    secret_key: ""
    region: ""
    bucket: local
  master_key: ""

internalmongo:
  credentials:
    secret_name: internal-mongo-password
    # The credentials to be used to communicate with Mongo and the database to be created
    root_username: ""
    root_password: ""
    database: ""
    admin_password: ""
    gmdata_username: ""
    gmdata_password: ""
  secret:
    secret_name: "internal-mongo-certs"
    certificates:
      # If from_file is true then you need to place cert files into the direcroty specified in path
      # Looking for ca.crt, server.cert, and server.key
      from_file:
        enabled: false
        path: files/certs/internalMongo
      ca: ""
      cert: ""
      key: ""

slo:
  ssl:
    name: slo-certs
    enabled: true
    certificates:
      # If from_file is true then you need to place cert files into the direcroty specified in path
      # Looking for ca.crt, server.cert, and server.key
      from_file:
        enabled: false
        path: files/certs/slo
      caName: "ca.crt"
      certName: "server.crt"
      keyName: "server.key"
      ca: ""
      cert: ""
      key: ""

postgres:
  credentials:
    secret_name: postgres-credentials
    # The credentials to be used to communicate with Postgres and the database to be created
    username: ""
    password: ""
    database: ""
  rds:
    enabled: false
  ssl:
    enabled: true
    name: postgres-ssl-certs
    certificates:
      # If from_file is true then you need to place cert files into the direcroty specified in path
      from_file:
        enabled: false
        path: files/certs/postgres
      caName: "ca.crt"
      certName: "server.crt"
      keyName: "server.key"
      ca: ""
      cert: ""
      key: ""
internalredis:
    # The password that will be used to authenticate with Redis
  password: ""
  secret_name: ""

internaljwt:
    # The password that will be used to authenticate with Redis
  redis_pass: ""
  secrets:
    secrets:
      from_file:
        enabled: false
        path: files/secrets/internalJwt
      name: internal-jwt-security-secret
      jwt.key: ""
      jwt.pub: ""
      jwt.api_key: ""
    certs:
      name: internal-jwt-certs
      # If from_file is true then you need to place cert files into the direcroty specified in path
      # Looking for ca.crt, server.cert, and server.key
      # When adding certs from file the secret assumes the jwt_* and server_* certs match.  Entering them via values file allows for differing certs
      from_file:
        enabled: false
        path: files/certs/internalJwtCerts
      jwt_cert_pem: ""
      jwt_key_pem: ""
      jwt_trust_pem: ""
      server_cert_pem: ""
      server_key_pem: ""
      server_trust_pem: ""

redis:
  # The password that will be used to authenticate with Redis
  password: redis
  secret_name: redis-password

jwt:
  # The password that will be used to authenticate with Redis
  redis_pass: redis
  secrets:
    certs:
      name: jwt-certs
      # If from_file is true then you need to place cert files into the direcroty specified in path
      # Looking for ca.crt, server.cert, and server.key
      # When adding certs from file the secret assumes the jwt_* and server_* certs match.  Entering them via values file allows for differing certs
      from_file:
        enabled: false
        path: files/certs/jwtCerts
      jwt_cert_pem: ""
      jwt_key_pem: ""
      jwt_trust_pem: ""
      server_cert_pem: ""
      server_key_pem: ""
      server_trust_pem: ""
    secrets:
      name: jwt-security
      from_file:
        enabled: false
        path: files/secrets/jwt
      jwt.key: ""
      jwt.pub: ""
      jwt.api_key: ""

sidecar:
  certificates:
    name: sidecar-certs
    # If from_file is true then you need to place cert files into the direcroty specified in path
    # Looking for ca.crt, server.cert, and server.key
    from_file:
      enabled: false
      path: files/certs/sidecar
    ca: ""
    cert: ""
    key: ""


edge:
  # This is a map of certificates that will be loaded into the edge service.
  # - Edge ingress represents the certificates presented to clients that attempt
  #   to gain access to the mesh from the external world
  # - Edge egress represents the certificates that edge will use to talk to the
  #   mesh. These certificates need to be issued from the same CA for certificates
  #   of the other sidecars, so they accept this certificate
  certificates:
    ingress:
      name: greymatter-edge-ingress
      # The edge ingress certs can be a unique certificates in some environments. This gives the option to provide a
      # unique ingress certificate for the cluster
      unique: true
      # If from_file is true then you need to place cert files into the direcroty specified in path
      # Looking for ca.crt, server.cert, and server.key      
      from_file:
        enabled: false
        path: files/certs/ingress
      ca: ""
      cert: ""
      key: ""
    egress:
      name: greymatter-edge-egress
      # If from_file is true then you need to place cert files into the direcroty specified in path
      # Looking for ca.crt, server.cert, and server.key
      from_file:
        enabled: false
        path: files/certs/egress
      ca: ""
      cert: ""
      key: ""
controlApi:
  ssl:
    name: "controlapi-certs"
    certificates:
      from_file:
        enabled: false
        path: files/certs/controlApi
      ca: ""
      cert: ""
      key: ""


control:
  controlApiTLS:
    name: "control-certs"
    certificates:
      # If from_file is true then you need to place cert files into the direcroty specified in path
      # Looking for ca.crt, server.cert, and server.key
      from_file:
        enabled: false
        path: files/certs/control
      ca: ""
      cert: ""
      key: ""


dashboard:
  ssl:
    name: dashboard-certs
    certificates:
      # If from_file is true then you need to place cert files into the direcroty specified in path
      # Looking for ca.crt, server.cert, and server.key
      from_file:
        enabled: false
        path: files/certs/dashboard
      caName: ca.crt
      certName: server.crt
      keyName: server.key
      ca: ""
      cert: ""
      key: ""
